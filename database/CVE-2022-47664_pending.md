# CVE-2022-47664

poc

[https://github.com/strukturag/libde265/files/10253597/660.zip](https://github.com/strukturag/libde265/files/10253597/660.zip)

fix

[https://github.com/strukturag/libde265/commit/9737c3ea73fa1fb47df0b91dcf5ba094b27376c6](https://github.com/strukturag/libde265/commit/9737c3ea73fa1fb47df0b91dcf5ba094b27376c6)

issue

[https://github.com/strukturag/libde265/issues/368](https://github.com/strukturag/libde265/issues/368)

```cpp
    #0 0x7fbe0e090cd3 in _mm_loadu_si128(long long __vector(2) const*) /usr/lib/gcc/x86_64-linux-gnu/12/include/emmintrin.h:703
    #1 0x7fbe0e090cd3 in ff_hevc_put_hevc_qpel_pixels_8_sse(short*, long, unsigned char const*, long, int, int, short*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/x86/sse-motion.cc:1972
    #2 0x7fbe0df8da46 in acceleration_functions::put_hevc_qpel(short*, long, void const*, long, int, int, short*, int, int, int) const /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/acceleration.h:336
    #3 0x7fbe0df8ea43 in void mc_luma<unsigned char>(base_context const*, seq_parameter_set const*, int, int, int, int, short*, int, unsigned char const*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/motion.cc:78
    #4 0x7fbe0df8064a in generate_inter_prediction_samples(base_context*, slice_segment_header const*, de265_image*, int, int, int, int, int, int, int, PBMotion const*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/motion.cc:373
    #5 0x7fbe0df8d020 in decode_prediction_unit(base_context*, slice_segment_header const*, de265_image*, PBMotionCoding const&, int, int, int, int, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/motion.cc:2107
    #6 0x7fbe0dfc9305 in read_coding_unit(thread_context*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4314
    #7 0x7fbe0dfcb1e0 in read_coding_quadtree(thread_context*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4652
    #8 0x7fbe0dfcb0f3 in read_coding_quadtree(thread_context*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4641
    #9 0x7fbe0dfcb08e in read_coding_quadtree(thread_context*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4638
    #10 0x7fbe0dfcb021 in read_coding_quadtree(thread_context*, int, int, int, int) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4635
    #11 0x7fbe0dfc297f in read_coding_tree_unit(thread_context*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:2861
    #12 0x7fbe0dfcb980 in decode_substream(thread_context*, bool, bool) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:4741
    #13 0x7fbe0dfcd622 in read_slice_segment_data(thread_context*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/slice.cc:5054
    #14 0x7fbe0df26d1a in decoder_context::decode_slice_unit_sequential(image_unit*, slice_unit*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:852
    #15 0x7fbe0df274e3 in decoder_context::decode_slice_unit_parallel(image_unit*, slice_unit*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:954
    #16 0x7fbe0df261e7 in decoder_context::decode_some(bool*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:739
    #17 0x7fbe0df25f61 in decoder_context::read_slice_NAL(bitreader&, NAL_unit*, nal_header&) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:697
    #18 0x7fbe0df28a3b in decoder_context::decode_NAL(NAL_unit*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:1239
    #19 0x7fbe0df2902a in decoder_context::decode(int*) /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/decctx.cc:1327
    #20 0x7fbe0df0fd64 in de265_decode /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/de265.cc:352
    #21 0x5641e7f9350b in main /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/dec265/dec265.cc:764
    #22 0x7fbe0dc46249 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #23 0x7fbe0dc46304 in __libc_start_main_impl ../csu/libc-start.c:360
    #24 0x5641e7f91400 in _start (/home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/build/dec265/dec265+0x5400)
```

fix 在 derive_spatial_luma_vector_prediction

decode_prediction_unit→motion_vectors_and_ref_indices→luma_motion_vector_prediction→fill_luma_motion_vector_predictors→derive_spatial_luma_vector_prediction

又看到一个bug，对于inline也处理不好，容易遗失

```cpp
Breakpoint 7, ff_hevc_put_hevc_qpel_pixels_8_sse (dst=0x7ffffffe2770, dststride=8, _src=0x61b00000d190 "", _srcstride=192, width=8, height=8,
    mcbuffer=0x7ffffffe0080)
    at /home/shangzhixu/shangzhi/RootCauseAnalyzer/gdb_test/RealWorldTest/CVE-2022-47664/libde265-1.0.9/libde265/x86/sse-motion.cc:1947
1947        uint8_t *src = (uint8_t*) _src;
(gdb) n
1948        ptrdiff_t srcstride = _srcstride;
(gdb) n
1949        x0= _mm_setzero_si128();
(gdb) n
1950        if(!(width & 15)){
(gdb) n
1968        }else if(!(width & 7)){
(gdb) n
1969            for (y = 0; y < height; y++) {
(gdb) n
1970                for (x = 0; x < width; x += 8) {
(gdb) n
1972                    x1 = _mm_loadu_si128((__m128i *) &src[x]);
(gdb) p src
$1 = (uint8_t *) 0x61b00000d190 ""
(gdb) p x
$2 = 0
(gdb) p src[0]
$3 = 0 '\000'
(gdb) p/x (uintptr_t)src % 16
$4 = 0x0
(gdb) p/x *((__m128i *)&src[x])
$5 = {0x0, 0x0}
```

说实话，看不懂为什么，这种太复杂了，数据流过分的复杂了

当然如果patch是这个就会好一些

[https://github.com/strukturag/libde265/pull/366/commits/36391cda3d4e4fb3269a2ce310e6e0f634729f0b](https://github.com/strukturag/libde265/pull/366/commits/36391cda3d4e4fb3269a2ce310e6e0f634729f0b)

1. **原本漏洞出现的场景**
    - 旧代码中，取到的 `SubWidthC`、`SubHeightC` 可能与 `img` 的真实色度抽样不匹配。
    - 例如，若实际是 4:2:0 (SubWidthC=2, SubHeightC=2)，但 PPS->sps 里存的却是 4:4:4 (SubWidthC=1, SubHeightC=1)。
    - 下游代码在计算引用地址时会**错误地**以 4:4:4 的方式跳过更少的字节，从而读到或写到未分配的区域，引发越界。
2. **修改后对齐**
    - 使用 `img->get_shared_sps()`, 保证 `SubWidthC`、`SubHeightC`、宽高、bit depth 等参数**都和图像实际数据一致**；
    - 后续在帧间预测或色度平面的地址计算中，就不会再越过实际分配边界。
3. **防止“陈旧SPS指针”**
    - 避免 PPS->sps 是旧的 / 半初始化的情况，也就杜绝了读取到无效地址或计算出错误偏移的风险。

---

## 4. 结论

> 一句话总结： “把 sps 的获取方式从 pps->sps.get() 改为 img->get_shared_sps().get()，实际上是确保后续使用的 SPS 参数与当前图像的内部配置保持同步、一致。原本因为 PPS->sps 不匹配（或无效）而导致的内存越界、崩溃等就自然消失了。”
> 

这看起来只是“一行小改动”，却实质上修正了 **SPS 与图像上下文** 的不一致，进而修复了由于错用参数导致的潜在缓冲区越界漏洞。

从两次 `p *sps` 的输出对比可见，**补丁后的 SPS 结构体**和**补丁前的**相比，最显眼的区别在于：

1. **SPS 的 sub_layer 数组、最大参考帧数、重排序数等字段出现了明显的无效值或随机值**
    - **补丁前：**
        - `profile_space = -66 '\276'`、`tier_flag = -66 '\276'`、`profile_idc = 3200171710`、
        - `sps_max_dec_pic_buffering = {1, 1, -1094795586, -1094795586, ...}` 等等。
        - 这些负数或巨大正数显然是无效／垃圾值，表明内存中数据已被“错误读”或“未初始化”。
    - **补丁后：**
        - 这些字段几乎都是 “0” 或正常的小数值（`profile_present_flag = 0`、`profile_space = 0` ...），
        - `sps_max_dec_pic_buffering = {1,1,0,0,0,0,0}`，没有出现异常的负值或极大值。
    - **现象**：补丁前的某些 sub_layer/数组在内存中**被错误填充**或**读到了别的内容**；补丁后则是正确解析出 0 或合理值。
2. **SPS 扩展标志 (sps_extension_6bits) 等也出现差异**
    - **补丁前**：`sps_extension_6bits = 8 '\b'`
    - **补丁后**：`sps_extension_6bits = 0 '\000'`
    - 这类字段在标准流里通常不会是太大的值，补丁前读到 `8` 也不算离谱，但结合其它字段出现的大量随机值，说明是**整体结构被误用**。
3. **整体结构的大部分字段值**（如 scaling_list、BitDepth_Y=8、chroma_format_idc=3、pic_width_in_luma_samples=192、pic_height_in_luma_samples=136）在补丁前后都大体一致，说明**关键分辨率等信息**相同，但**补丁前多了很多 “-66” 和 “-1094795586” 之类异常**，可见只是一部分内存被破坏或错误映射。

---

## **核心原因：为什么会有差异？**

- 在 HEVC 解码流程中，**SPS** 可能被多个地方引用，例如 `pps->sps`、`img->get_shared_sps()` 等。
- **补丁前**使用了错误的指针或老的 PPS->SPS 结构，导致 sub_layer 等数组字段的**指针（或解析）失配**，出现大量随机值 / 污染数据。
- **补丁后**改成了 `img->get_shared_sps()`（或类似修复），拿到了**真正匹配当前图像**的 SPS，sub_layer/数组得以正确解析或初始化为 0，所以就不会再出现那些负数或无效大数。

换言之，这些**-66**、**-1094795586** 以及 `3200171710` 之类的怪值是**典型的内存误读/损坏**特征：要么是指向了不该访问的区域、要么使用了未初始化的数据。

---

## **意味着什么？**

- **补丁前**：解码器在处理某些帧或片段时，拿到一个**并非当前有效**的 SPS 指针，从而**错误地解码** sub_layer 或 sps_max_dec_pic_buffering 之类字段。这会导致后续**越界访问**、崩溃等隐患。
- **补丁后**：用对了指针，SPS 的各项字段都与真实码流相符——**sub_layer** 默认都是 0（未使用的层），`sps_max_dec_pic_buffering[2..6]` 也不会莫名其妙地成为负数。
- 最终，解码器得以**正确走完整个解码流程**，不再提前因为越界或访问无效内存而挂掉。

---

## **总结**

> 两份 p *sps 的主要区别：
> 
> - **补丁前** 有大量 “\276 (-66)” 和 “-1094795586” 等无效随机值，显然是**SPS 结构里局部内存被破坏或指针用错**的迹象。
> - **补丁后** 那些字段要么是 0、1、2 等合法小数值，要么保留了合理的预设 (8-bit, 192x136, etc.)，表示**已正确解析**或**初始化**。

因此，**补丁**修正了 SPS 的获取方式，避免了**不匹配或被破坏的 SPS**导致“读到莫名其妙的数据”。也正因为这样，代码在后续使用 `sps->...` 各种参数时，就不会再发生越界、崩溃或安全漏洞。

所以其实是读取的问题，最终导致出错，修改之后整个数据流都改变了

```cpp
(gdb) p *refPic
$1 = {ID = 11, pixels = {0x61b00000cb80 '\200' <repeats 200 times>..., 0x61b00000d280 '\200' <repeats 200 times>...,
    0x61b00000d980 '\200' <repeats 200 times>...}, bpp_shift = "\000\000", chroma_format = de265_chroma_444,
  width = 192, height = 8, chroma_width = 192, chroma_height = 8, stride = 192, chroma_stride = 192,
  
refPic->get_image_plane(0)

就是返回 refPic->pixels[0] 这个指针，也就是图像亮度分量的首地址。
这也是你在 GDB 中看到的 0x61b00000cb80
```

改变之后，一直到

`ctx->acceleration.put_hevc_qpel`
数据流都没啥区别

但其实只能说数据流被改变了。。。